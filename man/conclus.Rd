% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conclus.R
\name{conclus}
\alias{conclus}
\title{Perform consensus clustering}
\usage{
conclus(diss, cluster = pamCons, subsample = 0.5, K = NULL, R = 100,
  verbose = FALSE, ncores = 1)
}
\arguments{
\item{diss}{A dissimilarity matris as returned by, for example, \code{dist}
or \code{daisy}.}

\item{cluster}{A clustering function that takes 2 arguments: \code{x} and \code{k}
and returns only the class memberships. Functions \code{pamCons} and \code{hclustCons}
are two simple examples. The dissimilarity matrix \code{diss} will be passed
into \code{cluster} so \code{cluster} should NOT coerce \code{x} to be a
dissimilarity matrix.}

\item{subsample}{The subsampling proportion. Defaults to \code{subsample=0.5}
and 50\% subsampling is performed. If \code{subsample == 1}, bootstrap
sampling (sampling with replacement) is performed.}

\item{K}{The maximum number of clusters to identify. All values between 2
and \code{K} are used and the consensus clustering matrix returned for
each.}

\item{R}{The number of random subsamples to run. Defaults to \code{R=100}.}

\item{verbose}{Whether to report progress. Defaults to \code{verbose=FALSE}.}

\item{ncores}{The number of cores to use. Defaults to \code{ncores=1} and it
is often the case that \code{conclus} will run faster on a single core than
when it makes the effort to parallelize. To have the function guess the
number of cores, specify \code{ncores=NULL}.}
}
\value{
An object of class `conclus'. It contains:
  \item{call}{the function call;}
  \item{M}{a list, with one element for each k in 2:K, representing the consensus matrices;}
  \item{membership}{a matrix with one column, for each k in 2:K, representing the cluster memberships;}
  \item{K}{the values of k in 2:K;}
  \item{cluster}{the function used to perform the clustering on the subsamples.}
}
\description{
Perform consensus clustering
}
\details{
R random subsamples (or bootstrap samples if \code{subsample = 1}) are
  taken from the dissimilarity matrix, and clustering is performed for each value
  of k = 2, ..., K. For each value of k, the consensus matrix is computed; each
  entry (i, j) represents the average number of times items i and j were in the same
  cluster. As such, each element of M is on [0, 1], with 0 or 1 representing perfect
  consensus. If items of the concensus matrix are arranged according to cluster
  membership, perfect consensus would be represented by a block diagonal form with
  blocks full of 1s surrounded by 0s.
}
\examples{
# The pluton data
cc <- conclus(dist(pluton), K=7) # default PAM clustering
ggplot(cc)
ggplot(summary(cc))
# Do the Gaussian3 and Unform1 examples from Monti et al
# First, they used average linkage, so define a new function
aveHclustCons <- function(x, k){
  stats::cutree(hclust(x, method="average"), k)
}
# Now pass it into conclus with the Gaussian3 data
ccg <- conclus(daisy(Gaussian3), K=6, cluster=aveHclustCons, subsample=.8, R=500, ncores=7)
ggplot(ccg, low="white", high="red")
s <- summary(ccg)
s
ggplot(s)
# Those are similar to Figures 2 and 3. Do the missing histogram
hist(ccg$M[[2]], col="red")

# Now Uniform 1
ccu <- conclus(daisy(Uniform1), K=6, cluster=aveHclustCons, subsample=.8, R=500, ncores=7)
ggplot(ccu, low="white", high="red")
su <- summary(ccu)
su
ggplot(su)
hist(c(ccu$M[[2]]), col="green")
}
\seealso{
\code{\link{pamCons}},  \code{\link{summary.conclus}}, \code{\link{representatives}}
}
\author{
Harry Southworth
}
